---
title: 大圣讲Vue源码笔记
date: 2022-05-27 20:41:55
permalink: /pages/fd1118/
sidebar: auto
categories:
  - 随笔
tags:
  - 
---
位运算
vue3.2中利用位运算，优化了速度。

位运算常常用于做权限管理。

举例padStart

---

在不用Vue的时候，dom和数据是分开的，如果数据发生变化后，则需要重新render()，即重新渲染页面；但是如果数据发生变化后，但是页面并没有用到该数据，重新渲染的话，会造成新能浪费。

这个时候就用到了proxy，对数据进行监听，当被页面依赖的数据发生变化的时候，才进行渲染。

再进一步，对项目进一步解耦，各个渲染函数分开。

Vue数据更新

数据初始化 =》 收集依赖关系
数据变化之后 =》 proxy响应式会通知到组件  // 组件内部虚拟dom 计算diff 汇总更新

React 数据更新

数据变化后 setState =》 计算虚拟dom =》 计算出diff =》 更新

两者区别在于：vue中是组件中计算虚拟dom，而react没有组件概念，所以是全部计算虚拟dom，项目大的话可能会卡。

react可能会卡，是如何解决的呢？
首先是事件切片，计算量虽然没有变化，但是利用在浏览器空闲的时间进行计算，感觉没那么卡了。

将fiber转成链表，可以中断执行，等空闲的时候再继续执行。

---
keepalive组件
页面跳转时候，保存组件状态。

组件状态缓存过多组件时候，涉及到cache淘汰的时候，LRU淘汰缓存。

lc 126 LRU缓存：

---

编译原理

与生成虚拟dom相似

Github 项目:the-der-tiny-compiler

--- 

为什么vite中不可以用require？

因为在开发环境中，是通过type=module的方式引入的，可以直接用import。

vite首先是支持的是esmodule，然后是支持node_modules、非js结尾的文件，还有热更新。

为什么vite首次加载慢？import时候，是发起的网络请求，如果依赖文件过多会首次加载慢，vite优化的时候，会对依赖包进行预打包，这样只会发起一次网络请求。

---
ni
