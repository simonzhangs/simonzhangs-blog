---
title: JS常见高级函数
date: 2022-04-16 21:57:19
permalink: /pages/e8ec12/
categories:
  - 《JavaScript教程》笔记
tags:
  -
---

## 1. 节流函数

在规定的一个单位时间内，事件只能触发一次；如果单位内触发多次函数，只有一次生效。

```js
function throttle(func, ms) {
  let timer = null;
  return function () {
    let that = this;
    let args = arguments;
    if (!timer) {
      timer = setTimeout(() => {
        timer = null;
        func.apply(that, args);
      }, ms);
    }
  };
}
```

## 2. 防抖函数

在事件被触发后 n 秒内再执行回调，如果 n 秒内再次触发，则重新计时。

```js
function debounce(func, ms) {
  let timer = null;
  return function () {
    let that = this;
    let args = arguments;
    if (timer) clearTimeout(timer);
    timer = setTimeout(() => {
      func.apply(that, args);
    }, ms);
  };
}
```

## 3. 深拷贝

对于数组、对象等类型时引用类型，变量标识符存储的指针指向堆中的对象，需要深拷贝赋值。

```js
function copy(obj) {
  let newObj = null;
  if (typeof obj == "object" && typeof obj !== null) {
    newObj = obj instanceof Array ? [] : {};
    for (let i in obj) {
      newObj[i] = copy(obj[i]);
    }
  } else {
    newObj = obj;
  }
  return newObj;
}
```

更加严谨的写法：

```js
function deepClone(obj={}){
  if(tyoeof obj !== 'object') { return obj;}

  let result = {};
  if(obj instanceof Array || Object.prototype.toString().call(obj) === '[object Arrray]') { result = [];}
  for(const key in obj) {
    if(obj.hasOwnProperty(key)) {
      result[key] = deepClone(obj[key]);
    }
  }
}
```

4. 手写 Promise.all

```js
function PromiseAll(arr) {
  // 将可迭代对象转换成一个数组
  let promises = Array.from(arr);
  const data = [];
  let index = 0,
    len = promises.length;
  return new Promise((resolve, reject) => {
    for (let i in promises) {
      // 需要并发执行，需要先resolve执行每个promise，再then
      Promise.resolve(promises[i])
        .then((res) => {
          // 不要用push，用下标存储，保证输出的顺序
          data[i] = res;
          if (++index === len) {
            resolve(data);
          }
        })
        .catch((err) => {
          reject(err);
        });
    }
  });
}
```

扩展：手写Promise.race:

```js
function promiseRace(iterator) {
  const promises = Array.from(iterator);
  return new Promise((resolve, reject) => {
    for(const i in promises) {
        Promise.resolve(promises[i])
          .then(res => resolve(res))
          .catch(err => reject(err));
    }
  })
}
```

## 5. 大数之和

尽量避免采用BigInt类型，比如说QQ好像就不支持，一般采用通用方法。

```js
function add(a, b) {
  let n = Math.max(a.length, b.length);
  a = a.padStart(n,0);
  b = b.padStart(n,0);

  let carry = 0;
  let res = '';
  for(let i = n - 1;i>=0;i--){
    let t = parseInt(a[i]) + parseInt(b[i]) + carry;
    carry = Math.floor(t/10);
    t = t % 10;
    res = t + res;
  }
  if(carry === 1) {
    res = '1' + res;
  }
  return res;
}
```



