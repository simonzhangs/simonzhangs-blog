---
title: Promise基础
date: 2022-04-22 16:03:44
permalink: /pages/8b1b5e/
categories:
  - 《JavaScript教程》笔记
  - JS基础
tags:
  -
---

Promise 特性：

1. Promise 的状态一经改变就不能再改变；

```js
const promise = new Promise((resolve, reject) => {
  resolve("success1");
  reject("error");
  resolve("success2");
});
promise
  .then((res) => {
    console.log("then: ", res);
  })
  .catch((err) => {
    console.log("catch: ", err);
  });
// "then: success1"
```

解析：构造函数中的`resolve`或`reject`只有第一次执行有效，多次调用没有任何作用；即 Promise 的状态一经改变就不能再改变。

2. `catch`不管被链接到哪里，都能捕获上层未捕获过的错误；`.then`和`.catch`都会返回一个新的 Promise；

```js
const promise = new Promise((resolve, reject) => {
  reject("error");
  resolve("success2");
});
promise
  .then((res) => {
    console.log("then1: ", res);
  })
  .then((res) => {
    console.log("then2: ", res);
  })
  .catch((err) => {
    console.log("catch: ", err);
  })
  .then((res) => {
    console.log("then3: ", res);
  });
// "catch: " "error"
// "then3: " undefined
```

解析： catch 不管连接到哪里，都可以捕获上层未捕获过的错误；then3 被执行是因为 catch()也会返回一个 Promise，且由于这个 Promise 没有返回值，所以打印出来的是 undefined。（因为 catch 到了错误，所以返回的 Promise 是成功态，但是没有返回值，故为 undefined）

3. 在 Promise 中，返回任意一个非`promise`的值都会包裹成 promise 对象；例如`return 2`会被包装成：`return Promise.resolve(2)`；

```js
Promise.resolve(1)
  .then((res) => {
    console.log(res);
    return 2;
  })
  .catch((err) => {
    return 3;
  })
  .then((res) => {
    console.log(res);
  });
// 1
// 2
```

解析：Promise 可以链式调用，不过 promise 每次调用`.then`或者`.catch`都会返回一个新的promise，从而实现链式调用，它并不像一般我们任务的链式调用一样`return this`。

上面的输出结果之所以依次打印出1和2，那是因为resolve(1)之后走的是第一个then方法，并没有走catch里，所以第二个then中的res得到的实际上是第一个then的返回值return 2，且return 2会被包装成resolve(2)。

同理，把上述题目中Promise.resolve(1)改Promise.reject(1)：

```js
Promise.reject(1)
  .then(res => {
    console.log(res);
    return 2;
  })
  .catch(err => {
    console.log(err);
    return 3
  })
  .then(res => {
    console.log(res);
  });
// 1
// 3
```

解析：打印的当然是 1 和 3啦，因为reject(1)此时走的就是catch，且第二个then中的res得到的就是catch中的返回值。

4. Promise的`.then`或者`.catch`可以被调用多次；但如果Promise内部的状态一经改变，并且有了一个值，那么后续每次调用`.then`或者`.catch`的时候都会直接拿到该值。

```js
const promise = new Promise((resolve, reject) => {
  setTimeout(() => {
    console.log('timer')
    resolve('success')
  }, 1000)
})
const start = Date.now();
promise.then(res => {
  console.log(res, Date.now() - start)
})
promise.then(res => {
  console.log(res, Date.now() - start)
})
// 'timer'
// 'success' 1001
// 'success' 1002
```

解析：Promise 的 .then 或者 .catch 可以被调用多次，但这里 Promise 构造函数只执行一次。或者说 promise 内部状态一经改变，并且有了一个值，那么后续每次调用 .then 或者 .catch 都会直接拿到该值。

5. .then或者.catch中return一个erro对象并不会抛出错误，所以不会被后续的.catch捕获；

```js
Promise.resolve().then(() => {
  return new Error('error!!!')
}).then(res => {
  console.log("then: ", res)
}).catch(err => {
  console.log("catch: ", err)
})
// "then: " "Error: error!!!"
```

解析： 它走的是.then,返回任意一个非promise的值都会被包裹成promise对象，因此这里的`return new Error('error!!!')`也会被包裹成`return Promise.resolve(new Error('error!!!'))`。

:::tip
如果要抛出一个错误的，建议采用：`return Promise.reject(new Error('error!!!'));`或`throw new Error('error!!!')`。
:::

6. .then或.catch返回的值不能是promise本身，否则会造成死循环。

```js
const promise = Promise.resolve().then(() => {
  return promise;
})
promise.catch(console.err)
```

上述程序会报错：
```js
Uncaught (in promise) TypeError: Chaining cycle detected for promise #<Promise>
```

7. .then 或者 .catch的参数期望是函数，传入非函数则会发生值透传；

```js
Promise.resolve(1)
  .then(2)
  .then(Promise.resolve(3))
  .then(console.log)
// 1
```

解析：第一个then和第二个then中传入的都不是函数，一个是数字类型，一个是对象类型，因此发生了透传，将resolve(1) 的值直接传到最后一个then里。

8. .then函数中存在两个参数，第一个参数是用来处理Promise成功的函数，第二个则是处理失败的函数；

```js
Promise.reject('error!!!')
  .then((res) => {
    console.log('success', res)
  }, (err) => {
    console.log('error', err)
  }).catch(err => {
    console.log('catch', err)
  })
// 'error' 'error!!!'
```

解析：它进入了.then()中的第二个参数里面，如果把第二个参数去掉，就会进入catch()中，因为catch会捕获上层所有未捕获的错误。

但是如果在then的第一个参数中丢出错误呢？

```js
Promise.resolve()
  .then(function success (res) {
    throw new Error('error!!!')
  }, function fail1 (err) {
    console.log('fail1', err)
  }).catch(function fail2 (err) {
    console.log('fail2', err)
  })
// fail2 Error: error!!!
// 			at success (C:\Users\zhang\Desktop\01.js:60:11)
```

解析：由于Promise调用的是resolve()，因此.then()执行的应该是success()函数，可是success()函数抛出的是一个错误，它会被后面的catch()给捕获到，而不是被fail1函数捕获。


---
> 参考：
> 
> [要就来45道Promise面试题一次爽到底(1.1w字用心整理)](https://juejin.cn/post/6844904077537574919#heading-24)