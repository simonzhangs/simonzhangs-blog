a---
title: JavaScript运行机制
date: 2022-03-29 21:36:42
permalink: /pages/c50093/
categories:
  - 《JavaScript面试问题》
tags:
  - 
---

JavaScript 是单线程的，当有异步任务时候运行结果会是什么样的？理解JS的运行机制很重要，在大型项目中应用需要理解透。先看这段代码会输出什么结果：

```js
console.log('script start')
setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2')
})

console.log('script end')
```

执行结果为：

```js
script start
promise1
script end
promise2
setTimeout
```

原因： 
首先，new Promise是同步任务，会被放到主进程中去立即执行（当作立即执行函数去理解）；而then()函数是异步任务，会放到异步队列中去，当这个promise状态结束（执行reject或resolve）的时候，就会立即放到异步队列中去。

上述代码包括promise和setTimeout的执行顺序，如果加上async/await呢，看下面代码：

```js
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end')
}
async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(function() {
  console.log('setTimeout')
}, 0)
async1();
new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2')
})

console.log('script end')
```

先看结果：

```js
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

JS执行机制：
1. 从上到下执行所有同步代码；
2. 在执行过程中，遇到宏任务就放到宏任务队列中；遇到微任务就放到微任务队列中；
3. 当所有同步代码执行完毕之后，就执行微任务队列中满足需求的所有回调；
4. 当微任务队列所有满足需求回调执行完毕之后，就执行宏任务队列中满足需求的所有回调。

> 在上面例子中：
> 1. new Promise是同步任务；
> 2. Promise.then() 是微任务，此外process.nextTick是node中的微任务；
> 3. 整体代码script、setTimeout、setInterval 是宏任务；
> 4. async 关键字函数会返回一个promise对象，如果里面没有await，执行起来等同于普通函数；
> 5. 如果有await关键字（await要在async关键字函数内部），await就会让出线程，阻塞async内后续代码，先去执行async外的代码，等外面同步代码执行完毕，才会执行后续的代码。
> 6. await如果等的是promise对象，则会阻塞后面的代码，等promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。


# JavaScript单线程语言

JavaScript是单线程语言，单线程意味着，所以的任务都需要排队，前一个任务结束才会执行下一个任务，如果前面任务耗费的时间很长，那后面的任务就得一直等着，这样的话会造成资源分配的浪费。所以为了规避这个问题，JavaScript把所有任务分为两种：同步任务和异步任务。

**同步任务：**在主线程上排队的任务，前一个任务执行完毕，才能执行下一个任务；
**异步任务：**不进入主线程，是进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，任务才会进入主线程执行。

## 同步与异步

异步：
- 计时器
- ajax
- 读取文件

同步程序执行完成后，执行异步程序；

```js
console.log(1);
setTimeout(()=>{console.log(2);},1000);
setTimeout(()=>{console.log(3);},100);
setTimeout(()=>{console.log(4);},1);
console.log(5); // 1 5 4 3 2
```

## 单线程

以下列代码举例子：

```js
for(let i=0;i<2000;i++) {
    console.log(1);
}
setTimeout(()=>{console.log(2);},1000);
setTimeout(()=>{console.log(3);},100);
setTimeout(()=>{console.log(4);},1);
console.log(5);
```

上述代码会先输出2000个1，再输出5 4 3 2，则计时器不准了，说明了JS是单线程的，一个任务完成后才能执行另一个任务；

## process.nextTick 和 setImmediate

nextTick 方法会在同步代码执行之后，异步执行之前执行。

setImmmediate 方法在异步代码执行之后执行。

# JavaScript的事件循环（eventloop）

先执行同步操作，异步操作排在事件队列里。

1. 先判断是同步还是异步任务，同步任务进入主线程，异步任务就进入event table；
2. 异步任务在event table中注册事件，当满足触发条件的时候，会被推入到event queue；
3. 同步任务进入到主线程中执行，当主线程空闲的时候，才会去event queue中看是否有需要执行的异步任务，如果有，就推入主线程执行。

# 宏任务与微任务

同步任务：new Promise内为同步任务。
异步任务分为：宏任务和微任务。
宏任务包括：setTimeout、setInterval、整体代码script
微任务包括：Promise.then()

执行顺序：先执行微任务然后执行宏任务。


# JS执行顺序总结

1. 同步先执行，异步后执行；
2. 遇到new Promise直接执行，then中的方法直接放入微任务队列；
3. 遇到setTimeout放入宏任务队列中；
4. 执行顺序：同步任务 -- 微任务（promise.then） -- 宏任务（setTimeout）


> 参考链接：
> 
> <a href="https://juejin.cn/post/6968815596393725983">关于async/await、promise和setTimeout的执行顺序</a>
> 
> <a href="https://juejin.cn/post/7016298598883131423">setTimeout+Promise+Async输出顺序？很简单呀！</a>
> 
> <a href="https://juejin.cn/post/6844904100195205133">setTimeout和setImmediate到底谁先执行，本文让你彻底理解Event Loop</a>

# 扩展-浏览器的进程

JS执行的是单线程的，而JS执行是在浏览器中，占用的是浏览器中的一个线程。浏览器不仅是多线程的，而且还是多进程的。

![浏览器进程](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/128265bfc2be4ede80c06927c6e78d0b~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

JS执行的在浏览器的渲染进程中的JS引擎线程完成的。渲染进程也不止一个，每个选项卡都有自己的渲染进程，这样单页页面崩溃不会导致浏览器崩溃。

渲染进程是前端主要用到的，其他包括以下进程：

## GUI线程

GUI线程负责渲染页面的，用来解析HTML和CSS，然后将他们构建DOM树、CSSOM树，还有渲染树，都是GUI线程负责的。

## JS引擎线程

**JS引擎线程就是负责执行JS的主线程**，JS的单线程指的就是这个线程，也就是我们所说的Chrome V8引擎是在这个线程运行的。

> JS引擎线程和GUI线程是互斥。因为JS是可以操作DOM的，如果JS线程和GUI线程同时操作DOM，就比较混乱，不知道到底渲染哪个结果，所以说如果JS长时间运行，GUI线程就会被阻塞，整个页面感觉像卡死了。

## 定时器线程

JS定时器方法有setTimeout、setTimeout，它们都运行在定时器线程，跟JS主线程根本不在一个地方，所以JS作为单线程语言，能够实现异步。

## 事件触发线程

定时器线程其实只是一个计时的作用，他并不会真正执行时间到了的回调，真正执行这个回调的还是JS主线程。

当时间到了定时器会将这个回调时间给到事件触发线程，然后事件触发线程将它加到事件队列里面去，最终JS主线程从事件队列取出这个回调执行。

事件触发线程不仅会将定时器事件放入任务队列，其他满足条件的事件也是他负责放进任务队列。

## 异步HTTP请求线程

这个线程负责处理异步的ajax请求，当请求完成后，也会通知事件触发线程，然后时间触发线程将这个事件放入事件队列给主线程执行。

总之，JS异步的实现实际是靠的是浏览器的多线程，当他遇到异步API时候，就将这个任务交给对应的线程；当这个异步API满足回调条件时，对应的线程又通过事件触发线程将这个事件放入任务队列，然后主线程从任务队列取出事件继续执行。这里说的任务队列就是Event Loop，目前JS的运行环境有两个：浏览器和Node.js，两者 event loop有不同的地方。

# Event Loop

## 浏览器的Event Loop

事件循环就是一个循环，是各个异步线程用来通讯和协同执行的机制。各个线程为了交换消息，还有一个公用的数据区，就是事件队列。各个异步线程执行完了之后，通过事件触发线程就回调事件放到事件队列，主线程每次干完手上的活儿就来看这个队列有没有新活，有的话就取出来执行。

![浏览器event loop](https://p3-juejin.byteimg.com/tos-cn-i-k3u1fbpfcp/da2a8fb96e8c49d08589c1c31470d366~tplv-k3u1fbpfcp-zoom-in-crop-mark:1304:0:0:0.awebp)

流程如下：
1. 主线程每次执行的时候，先看看要执行的是同步任务，还是异步的API；
2. 同步任务就继续执行，一直执行完；
3. 遇到异步API就将他交给对应的异步线程，自己继续执行同步任务；
4. 异步线程执行异步API，执行完后，将异步回调时事件通过事件触发线程放入事件队列中；
5. 主线程手上的同步任务完成后就来看事件队列里面有没有任务；
6. 主线程发现事件队列有任务，就取出里面的任务执行；
7. 主线程不断循环上述流程。

## 定时器不准

因为定时器是到了时间会经过事件触发线程放入事件队列中，并且等到主线程执行完之后再来执行，如果主线程被阻塞时间超过定时器时间的话，定时器就不准了。因此要主要不要过长时间占用主线程。

## 微任务

事件队列里面的事件分为两类：宏任务和微任务。其中微任务拥有更高的优先级，当事件循环遍历队列时，会先检查微任务队列，如果有任务，就全部拿来执行，执行完毕之后再执行一个宏任务。执行每个宏任务之前都要检查下微任务队列是否有任务，如果有，优先执行微任务队列。

常见的宏任务和微任务有：
## 宏任务

|#	|浏览器	|Node|
| :-----:| :----: | :----: |
|I/O	|✅	|✅|
|setTimeout	|✅	|✅|
|setInterval	|✅	|✅|
|setImmediate	|❌	|✅|
|requestAnimationFrame	|✅	|❌|

## 微任务

|#	|浏览器	|Node|
| :-----:| :----: | :----: |
|Promise.prototype.then catch finally	|✅	|✅|
|process.nextTick	|❌	|✅|
|MutationObserver	|✅	|❌|

# 补充

浏览器的渲染进程中，主线程是用来进行DOM解析渲染和JS解析运行的，还有合成器线程，不是在主线程中的，将渲染的结果通过IPC传递给浏览器进程，然后传给GPU进行绘制。

如果进行大量的重绘重拍的话，会影响性能；

此外如何避免动画卡顿，人眼在60Hz刷新率的情况下看不到卡顿，但是如果因为JS执行在主线程上的，如果JS阻塞了话，会影响合成器线程渲染，导致页面看上去卡顿：
可以通过requestAnimationFrame来将JS切割在每帧空余的时间运行，避免影响渲染；
通过tranform来实现动画，因为tranform动画占用主线程的绘制计算，而是在合成器线程进行的。