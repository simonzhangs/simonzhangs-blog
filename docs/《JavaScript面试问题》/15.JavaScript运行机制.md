---
title: JavaScript运行机制
date: 2022-03-29 21:36:42
permalink: /pages/c50093/
categories:
  - 《JavaScript面试问题》
tags:
  - 
---

JavaScript 是单线程的，当有异步任务时候运行结果会是什么样的？理解JS的运行机制很重要，在大型项目中应用需要理解透。先看这段代码会输出什么结果：

```js
console.log('script start')
setTimeout(function() {
  console.log('setTimeout')
}, 0)

new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2')
})

console.log('script end')
```

执行结果为：

```js
script start
promise1
script end
promise2
setTimeout
```

原因： 
首先，new Promise是同步任务，会被放到主进程中去立即执行（当作立即执行函数去理解）；而then()函数是异步任务，会放到异步队列中去，当这个promise状态结束（执行reject或resolve）的时候，就会立即放到异步队列中去。

上述代码包括promise和setTimeout的执行顺序，如果加上async/await呢，看下面代码：

```js
async function async1() {
  console.log('async1 start');
  await async2();
  console.log('async1 end')
}
async function async2() {
  console.log('async2')
}
console.log('script start')
setTimeout(function() {
  console.log('setTimeout')
}, 0)
async1();
new Promise(function(resolve) {
  console.log('promise1');
  resolve();
}).then(function() {
  console.log('promise2')
})

console.log('script end')
```

先看结果：

```js
script start
async1 start
async2
promise1
script end
async1 end
promise2
setTimeout
```

JS执行机制：
1. 从上到下执行所有同步代码；
2. 在执行过程中，遇到宏任务就放到宏任务队列中；遇到微任务就放到微任务队列中；
3. 当所有同步代码执行完毕之后，就执行微任务队列中满足需求的所有回调；
4. 当微任务队列所有满足需求回调执行完毕之后，就执行宏任务队列中满足需求的所有回调。

> 在上面例子中：
> 1. new Promise是同步任务；
> 2. Promise.then() 是微任务，此外process.nextTick是node中的微任务；
> 3. 整体代码script、setTimeout、setInterval 是宏任务；
> 4. async 关键字函数会返回一个promise对象，如果里面没有await，执行起来等同于普通函数；
> 5. 如果有await关键字（await要在async关键字函数内部），await就会让出线程，阻塞async内后续代码，先去执行async外的代码，等外面同步代码执行完毕，才会执行后续的代码。
> 6. await如果等的是promise对象，则会阻塞后面的代码，等promise对象resolve，然后得到resolve的值，作为await表达式的运算结果。


# JavaScript单线程语言

JavaScript是单线程语言，单线程意味着，所以的任务都需要排队，前一个任务结束才会执行下一个任务，如果前面任务耗费的时间很长，那后面的任务就得一直等着，这样的话会造成资源分配的浪费。所以为了规避这个问题，JavaScript把所有任务分为两种：同步任务和异步任务。

**同步任务：**在主线程上排队的任务，前一个任务执行完毕，才能执行下一个任务；
**异步任务：**不进入主线程，是进入任务队列的任务，只有任务队列通知主线程，某个异步任务可以执行了，任务才会进入主线程执行。

## 同步与异步

异步：
- 计时器
- ajax
- 读取文件

同步程序执行完成后，执行异步程序；

```js
console.log(1);
setTimeout(()=>{console.log(2);},1000);
setTimeout(()=>{console.log(3);},100);
setTimeout(()=>{console.log(4);},1);
console.log(5); // 1 5 4 3 2
```

## 单线程

以下列代码举例子：

```js
for(let i=0;i<2000;i++) {
    console.log(1);
}
setTimeout(()=>{console.log(2);},1000);
setTimeout(()=>{console.log(3);},100);
setTimeout(()=>{console.log(4);},1);
console.log(5);
```

上述代码会先输出2000个1，再输出5 4 3 2，则计时器不准了，说明了JS是单线程的，一个任务完成后才能执行另一个任务；

## process.nextTick 和 setImmediate

nextTick 方法会在同步代码执行之后，异步执行之前执行。

setImmmediate 方法在异步代码执行之后执行。

# JavaScript的事件循环（eventloop）

先执行同步操作，异步操作排在事件队列里。

1. 先判断是同步还是异步任务，同步任务进入主线程，异步任务就进入event table；
2. 异步任务在event table中注册事件，当满足触发条件的时候，会被推入到event queue；
3. 同步任务进入到主线程中执行，当主线程空闲的时候，才会去event queue中看是否有需要执行的异步任务，如果有，就推入主线程执行。

# 宏任务与微任务

同步任务：new Promise内为同步任务。
异步任务分为：宏任务和微任务。
宏任务包括：setTimeout、setInterval、整体代码script
微任务包括：Promise.then()

执行顺序：先执行微任务然后执行宏任务。

# JS执行顺序总结

1. 同步先执行，异步后执行；
2. 遇到new Promise直接执行，then中的方法直接放入微任务队列；
3. 遇到setTimeout放入宏任务队列中；
4. 执行顺序：同步任务 -- 微任务（promise.then） -- 宏任务（setTimeout）







