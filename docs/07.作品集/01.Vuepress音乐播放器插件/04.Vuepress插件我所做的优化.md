---
title: Vuepress插件我所做的优化
date: 2022-05-03 20:45:00
permalink: /pages/a111d8/
categories:
  - 作品集
  - Vuepress音乐播放器插件
tags:
  - 
---

今天终于做了一个较大的优化，当然也顺带修复了上个版本的各种bug，也顺便引入了一些新的bug，留着下次修复吧....... 还是先记录下自己做的优化吧！

关于Vuepress插件，之前就发现了它的一个问题：就是每新开一个页面，播放器会重头开始播放，根本就记不住之前播放到了哪里！！！这怎么能行呢，要解决这个问题的话，关键点在于播放状态的共享。查阅了以下资料，新开的页面协议、主机和端口号都没有变化，只是路径发生变化，还是处于同源下的，最简单的方法就是利用localStorage在同源页面上进行状态共享。

## 状态共享思路

既然要共享的话，如果新开了一个页面，信息状态同步的方式是怎么的呢？是播放新页面的音乐呢，还是继续播放旧页面的音乐呢？

我尝试去参考了两大巨头的思路：
- 某Q：不管从哪个页面点击播放音乐会单开一个播放列表页面，或者跳转到播放列表页面；通过这个页面来管理所有的播放音乐。（这不适用于我这种情况啊）
- 某云：每个页面底部在播放状态下，都会有一个播放器，它们只会共享当前播放歌曲，不共享播放当前进度；同时不同页面播放和暂停状态是互斥的，只能有一个处于播放状态。（而且新开的页面不会去主动请求歌曲信息，只有在播放的时候请求，也有可能是读取缓存的，是网络优化的一个小细节啊）

再结合这个插件的特性，音乐播放我设计时决定还是放在原来页面播放，但要保证新开页面能够同步播放歌单和播放进度，同时要保证多个页面只有一个处于播放状态。

:::tip
上述问题其实总结起来是：`前端如何跨页面通信`，除了利用localStorage方法外，~~它是在同源页面上进行通信~~，还有其他方式，我总结在这篇文章里面了：[扩展-跨页面通信](/pages/a111d8/#扩展-跨页面通信)
:::

## 跨页面通信

下面则是记录利用localStorage来进行跨页面通信，从而共享播放状态：

### 1. 修复上个版本刷新页面重新播放，以及新开一个tab栏也会重新播放的bug

排查发现在`created(){}`生命周期里，写了这么一段代码：

```js
created() {
    // 此时可以访问this，做数据初始化；或者异步数据请求
    this.init();
    // this.playPlaylistByID(this.playListID);
},
```

我直接把播放歌单的函数写在了数据初始化这个生命周期里；这样每次刷新和新开页面当然会重新开始播放啊。果断注释掉这段代码，那这样的话刚开始歌单播放放在哪里呢，思考一番决定放在`init()`，通过条件判断，如果已经加载了对应歌单的话，从缓存中读取，如果首次运行的话，则加载传入的歌单ID。

怎么判断是否首次运行呢？当然是判断缓存里面是否存在歌曲，我选择的是player._list这个属性，它代表的是当前播放歌单列表，如果存在的话，说明已经不是首次加载了，直接读取缓存内容，否则则初始化player信息，存储到缓存中。

```js
init() {
  // 读取缓存内容
  this._loadSelfFromLocalStorage();
  Howler.autoUnlock = false;
  Howler.usingWebAudio = true;
  Howler.volume(this.volume);

  // 如果没有读取到，说明是首次使用插件，则加载配置歌单ID
  if (!this.player._list) {
    this.playPlaylistByID(this.playListID);
  }
  // 不是首次加载的话，读取缓存
  if (this.player._enabled) {
    // 恢复当前播放歌曲
    this._replaceCurrentTrack(this.player._currentTrack.id, false).then(
      () => {
        let time = 0;
        // if (localStorage.getItem("playerCurrentTrackTime")) {
        //   time = localStorage.getItem("playerCurrentTrackTime");
        // }
        if (this.player._progress) {
          time = this.player._progress;
        }
        this.player._howler?.seek(time);
        this.player._playing = false;
      }
    );
    // ......
  }
  // ......
},
```

改进：在测试时候发现，首次加载的话，player还没有初始化，从而选择缓存中是否存在player项判断，这样更加合理。

```js
// 首次使用插件时候加载配置歌单ID
  if (typeof process == "undefined") {
    if (!localStorage.getItem('player')) {
      this.playPlaylistByID(this.playListID);
    }
  }
```

### 2. Vuepress插件（node端编译）怎么控制localStorage读写

因为Vuepress插件是在node端编译的，而node端根本没有localStorage啊！这里采用了npm依赖包`node-localstorage`，它可以在node端操作localStroage，并且操作localStorage方法和浏览器端一样。

```js
created() {
    // ......
    if (typeof localStorage === "undefined" || localStorage === null) {
      var LocalStorage = require("node-localstorage").LocalStorage;
      localStorage = new LocalStorage("./scratch");
    }

    // localStorage.setItem("myFirstKey", "myFirstValue1");
},
```

通过上述三行代码就可以创建一个全局的localStorage对象，并且可以进行缓存设置、读取和删除，但是只能在node端使用，生产环境还是用不了。开发环境下它并没有进行html渲染；而在正式环境中`npm run build`有以下步骤：

```html
√ Client
  Compiled successfully in 1.77m

√ Server
  Compiled successfully in 1.52m

wait Rendering static HTML...
```

在渲染静态html时候，是在node端进行地，自然是没有localStroage的，最终通过判断`typeof process`JS运行环境，在浏览器端环境条件下，才进行localStorage的操作，这是实现信息的共享的基础啦。记下来要关注的就是，信息什么时候存储、什么时候读取呢？

```js
if (typeof process === "undefined") {
  // 当前环境为浏览器端，做localStroage的存取操作
  }
```

### 3. localStorage存储和取出逻辑

首先什么数据需要存储到localStroage里面呢？这个不需要过多思考，player.vue组件中data(){}中的数据，关于播放数据，我都放在了`player{}`对象中了：

```js
data() {
    return {
      player: {
        _playing: false, // 是否正在播放中
        _progress: 0, // 当前播放歌曲的进度
        _enabled: false, // 是否启用Player
        _repeatMode: "off", // off | on | one
        _shuffle: false,
        _reversed: false,
        _volume: 1, // 0 to 1
        _volumeBeforeMuted: 1, // 用于保存静音前的音量

        _list: [], // 播放列表
        _shuffledList: [], // 被随机打乱的播放列表，随机播放模式下会使用此播放列表
        _current: 0, // 当前播放歌曲在播放列表里的index
        _playlistSource: { type: "album", id: 123 }, // 当前播放列表的信息
        _currentTrack: { id: 86827685 }, // 当前播放歌曲的详细信息
        _playNextList: [], // 当这个list不为空时，会优先播放这个list的歌
        // howler (https://github.com/goldfire/howler.js)
        _howler: null,
      },
      // ......
    };
}
```

player这个对象中包括了当前播放歌曲、播放歌单、播放进度等信息，其中主要发生变化的则是`_playing`、`_currentTrack`这几个，其他大部分时间不会变化。那么什么时候存储到localStorage里面，能够保证读取的时候也是最新的状态呢？

这个时候就用到了Vue的生命周期钩子updated(),此生命周期表示data(){}中的数据发生变化，同时已经更新到视图当中了。将缓存存储写在这里，可以保证没有存储的都是最新的播放信息。

```js
updated() {
    this.saveSelfToLocalStorage();
}

// 缓存播放信息
saveSelfToLocalStorage() {
  let player = {};
  for (let [key, value] of Object.entries(this.player)) {
    if (key == "_howler") {
      continue;
    }
    player[key] = value;
  }
  if (typeof process === "undefined") {
    localStorage.setItem("player", JSON.stringify(player));
  }
}
```

:::tip
这里_howler是howler.js的播放器对象，因为存在循环引用，所以决定不保存到缓存里面，而是选择在新开页面created()之后，销毁重新生成一个。
:::

接下来是取出localStroage逻辑：当vue数据初始化完毕之后，在created中进行数据初始化`init()`时，读取localStroage数据赋值给data()中的player对象，这样子就实现了跨页面同步播放状态啦！还有一个问题是：还不能保证同时只有一个在播放，暂时还没想到解决方案。

```js
created() {
  // 此时可以访问this，做数据初始化；或者异步数据请求
  this.init();
}

init() {
  this._loadSelfFromLocalStorage();
  Howler.autoUnlock = false;
  Howler.usingWebAudio = true;
  Howler.volume(this.volume);
  // ......
}

//player 实例对象从缓存读取
_loadSelfFromLocalStorage() {
  if (typeof process === "undefined") {
    const player = JSON.parse(localStorage.getItem("player"));
    if (!player) return;
    for (const [key, value] of Object.entries(player)) {
      this.player[key] = value;
    }
  }
}
```


## 扩展-跨页面通信

在同源页面间的跨页面通信，除了localStroage之外，这里还有这几种：

### 1. BroadCast Channel

创建一个用于广播的通信频道。当所有页面都监听同一频道的消息时，其中某一个页面通过它发送的消息就会被其他所有页面收到。

```js
// 创建一个具有simonzhangs blog标识的频道
const bc = new BroadcastChannel('Simonzhangs blog');

// 各个页面通过onmessage来监听被广播的消息
bc.onmessage = function(e) {
  const data = e.data;
  const text = '[receive] ' + data.msg + ' —— tab ' + data.from;
  console.log('[BroadcastChannel] receive message:', text);
}

// 页面调用实例上的postMessage方法来发送消息
bc.postMessage(mydata)
```

Broadcast Channel 是一个非常好用的多页面消息同步 API，然而兼容性却不是很乐观。

### 2. Service Worker



### 3. Shared Worker

### 4. IndexedDB

### 5. window.open + window.opener

### 6. 非同源页面-iframe


## 扩展-判断JS是否运行环境

### 1. globalThis

通过判断XMLHttpRequest类型来判断，异步http请求只存在于浏览器端：

```js
function canMakeHTTPRequest() {
  return typeof globalThis.XMLHttpRequest === 'function';
}

console.log(canMakeHTTPRequest());
// expected output (in a browser): true
```

:::tip
全局属性 globalThis 包含全局的 this 值，类似于全局对象（global object）。globalThis 提供了一个标准的方式来获取不同环境下的全局 this  对象（也就是全局对象自身）,为便于记忆，你只需要记住，全局作用域中的 this 就是 globalThis。

浏览器端与node端区别：
- 在node环境中this指向global，而浏览器环境中this则指向window；
- Node采用commonJS标准，而浏览器采用ES Modules标准；（require/ module.exports , import/export）
- Node不可以操作DOM，而浏览器JS可以操作DOM；（服务端技术，不需要页面操作 / 表现层，需要页面交互操作）
- I/O读写操作不同；（buffer）
- 模块加载不同。（浏览器端，会涉及到闭包，原生没提供包引用的API会一次性把要加载的东西全执行以便，没有逻辑性和复用性 / node端 npm依赖包管理工具）
:::

### 2. typeof + Object.prototype.toString().call()

```js
if (typeof window === 'object' && Object.prototype.toString.call(window) === '[object Window]'){
	// window只存在于浏览器端
}else if(Object.prototype.toString.call(process) === '[object process]'){
	//判断procss
}
```


> 参考链接：
> [前端跨页面通信，你知道哪些方法？](https://juejin.cn/post/6844903811232825357)